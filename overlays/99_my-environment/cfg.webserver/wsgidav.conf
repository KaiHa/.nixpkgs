################################################################################
# Sample WsgiDAV configuration file
#
# 1. Rename this file to `wsgidav.conf`
# 2. Adjust settings as appropriate
# 3. Run `wsgidav` from the same directory or pass file name with `--config` option.
#
# NOTE: the recommended configuration file format is now YAML.
#
# See http://wsgidav.readthedocs.io/en/latest/user_guide_configure.html
#

# HELPERS - Do not modify this section

provider_mapping = {}


def addShare(shareName, davProvider):
    provider_mapping[shareName] = davProvider


################################################################################
# SERVER OPTIONS
#===============================================================================
# Run WsgiDAV inside this  WSGI server.
# Supported servers: "cheroot", "cherrypy-wsgiserver", "ext_wsgiutils",
#     "flup-fcgi", "flup-fcgi-fork", "paste", "wsgiref"
# 'wsgiref' and 'ext_wsgiutils' are simple builtin servers that should *not* be
# used in production.
# All other servers must have been installed before, e.g. `pip install cheroot`.
# (The binary MSI distribution already includes 'cheroot'.)
# Default: "cheroot", use the --server option on command line to change this.

#server = "cheroot"

# Additional arguments passed to the server on initialization (depends on `server`)
# For example for cheroot:

#server_args = {
#    "numthreads": 10,
#    "max": -1,
#    "request_queue_size": 5,
#    "timeout": 10,
#    "shutdown_timeout": 5,
#    "verbose": 0,
#}

# Server port (default: 8080, use --port on command line)
port = 49094

# Server hostname (default: localhost, use --host on command line)
host = "schubiduschubi"

#===============================================================================
# Enable SSL support

ssl_certificate = "/etc/letsencrypt/live/schubiduschubi.de/fullchain.pem"
ssl_private_key = "/etc/letsencrypt/live/schubiduschubi.de/privkey.pem"
# ssl_certificate_chain = None

# Cheroot server supports 'builtin' and 'pyopenssl' (default: 'builtin')
# ssl_adapter = "pyopenssl"


#================================================================================
# Misc. setings
#

# Block size in bytes

# block_size = 8192


# Set this to True, to force unquoting of PATH_INFO. This should already be done by the WSGI
# Framework, so this setting should only be used to fix unexpected problems there (see issue #8).

# unquote_path_info = False


# Re-encode PATH_INFO using UTF-8 (falling back to ISO-8859-1).
# This seems to be wrong, since per PEP 3333 PATH_INFO is always ISO-8859-1 encoded
# (see https://www.python.org/dev/peps/pep-3333/#unicode-issues).
# However it seems to resolve errors when accessing resources with Chinese characters, for
# example (see issue #73).
# Set to `None` (the default) to enable this for Python 3 only.

# re_encode_path_info = None


#===============================================================================
# Middlewares
#
# Use this section to override the default middleware stack

#from wsgidav.dir_browser import WsgiDavDirBrowser
#from debug_filter import WsgiDavDebugFilter
#from http_authenticator import HTTPAuthenticator
#from error_printer import ErrorPrinter
#middleware_stack = [ WsgiDavDirBrowser, HTTPAuthenticator, ErrorPrinter, WsgiDavDebugFilter ]

#===============================================================================
# Debugging

verbose = 3          # 0 - quiet
                     # 1 - no output (excepting application exceptions)
                     # 2 - warnings and errors only
                     # 3 - show single line request summaries (HTTP logging)
                     # 4 - show additional events
                     # 5 - show full request/response header info (HTTP Logging)
                     #     request body and GET response bodies not shown


# Enable specific module loggers
# E.g. ["lock_manager", "property_manager", "http_authenticator", ...]
enable_loggers = []

# Enable max. logging for certain http methods
# E.g. ["COPY", "DELETE", "GET", "HEAD", "LOCK", "MOVE", "OPTIONS", "PROPFIND", "PROPPATCH", "PUT", "UNLOCK"]
debug_methods = []

# Enable max. logging during  litmus suite tests that contain certain strings
# E.g. ["lock_excl", "notowner_modify", "fail_cond_put_unlocked", ...]
debug_litmus = []


################################################################################
# WsgiDavDirBrowser
# to enable dir browsing put WsgiDavDirBrowser into middleware_stack config option (see above)

dir_browser = {
    "enable": True,               # Render HTML listing for GET requests on collections
    "ignore": [],
    "response_trailer": "",       # Raw HTML code, appended as footer
    "davmount": False,            # Send <dm:mount> response if request URL contains '?davmount'
    "ms_mount": False,            # Add an 'open as webfolder' link (requires Windows)
    "ms_sharepoint_support": True,  # Invoke MS Offce documents for editing using WebDAV
}


################################################################################
# DAV Provider

#===============================================================================
# Property Manager
#
# Uncomment this lines to specify your own property manager.
# Default:        no support for dead properties
# Also available: wsgidav.prop_man.property_manager.PropertyManager
#                 wsgidav.prop_man.property_manager.ShelvePropertyManager
#
# Check the documentation on how to develop custom property managers.
# Note that the default PropertyManager works in-memory, and thus is NOT
# persistent.

### Use in-memory property manager (NOT persistent)
# (this is the same as passing 'property_manager = True')
#from wsgidav.prop_man.property_manager import PropertyManager
#property_manager = PropertyManager()

### Use persistent shelve based property manager
#from wsgidav.prop_man.property_manager import ShelvePropertyManager
#property_manager = ShelvePropertyManager("wsgidav-props.shelve")

### Use in-memory property manager (NOT persistent)
property_manager = True


### Optional additional live property modification
# Note: by default live properties like file size and last-modified time are
# read-only, but that can be overriden here if the underlying DAV provider
# supports it. For now only the FileSystemProvider supports it and only namely
# changes to the last-modified timestamp. Enable it with the mutable_live_props
# list as below to allow clients to use the utime system call or e.g. the
# touch or cp / rsync commands with the preserve-timestamp flags on a mounted
# DAV share.
# Please note that the timestamp is set on the actual file or directory, so it
# is persistent even for in-memory property managers. It should also be noted
# that mutable last-modified may not be compliant with the RFC 4918.

# mutable_live_props = ["{DAV:}getlastmodified"]


#===============================================================================
# Lock Manager
#
# Uncomment this lines to specify your own locks manager.
# Default:        wsgidav.lock_storage.LockStorageDict
# Also available: wsgidav.lock_storage.LockStorageShelve
#
# Check the documentation on how to develop custom lock managers.
# Note that the default LockStorageDict works in-memory, and thus is NOT
# persistent.

# Example: Use in-memory lock storage
#          (this is the same as passing 'lock_manager = True', which is default)
#from wsgidav.lock_storage import LockStorageDict
#lock_manager = LockStorageDict()


# Example: Use PERSISTENT shelve based lock manager
#from wsgidav.lock_storage import LockStorageShelve
#lock_manager = LockStorageShelve("wsgidav-locks.shelve")


################################################################################
# SHARES
#
# If you would like to publish files in the location '/v_root' through a
# WsgiDAV share 'files', so that it can be accessed by this URL:
#     http://server:port/files
# insert the following line:
#     addShare("files", "/v_root")
# or on a Windows box:
#     addShare("files", "c:\\v_root")
#
# To access the same directory using a root level share
#     http://server:port/
# insert this line:
#     addShare("", "/v_root")
#
# The above examples use wsgidav.fs_dav_provider.FilesystemProvider, which is
# the default provider implementation.
#
# If you wish to use a custom provider, an object must be passed as second
# parameter. See the examples below.


### Add a read-write file share:
from wsgidav.fs_dav_provider import FilesystemProvider
addShare("4vnlzptiozzmyv/webdav", FilesystemProvider("/home/kai/org"))

### Add a read-only file share:
#from wsgidav.fs_dav_provider import FilesystemProvider
#addShare("tmp", FilesystemProvider("/tmp", readonly=True))


################################################################################
# AUTHENTICATION
#===============================================================================
# HTTP Authentication Options

http_authenticator = {
    "domain_controller": None,  # Use SimpleDomainController
    "accept_basic": True,  # Allow basic authentication, True or False
    "accept_digest": True,  # Allow digest authentication, True or False
    "default_to_digest": True,  # True (default digest) or False (default basic)
    # Enter the name of a header field that will be accepted as authorized user.
    # Including quotes, for example: trusted_auth_header = "REMOTE_USER"
    "trusted_auth_header": None,
    }


simple_dc = {
          "user_mapping": {
            "*" : { "kai": {"password": open("/home/kai/.wsgidav.pwd").read() } }
            }
    }
